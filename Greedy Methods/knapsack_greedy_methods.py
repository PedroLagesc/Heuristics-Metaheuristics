# -*- coding: utf-8 -*-
"""Knapsack_greedy_methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ip1uqOovS4xp1UZwFV0DxgiI4_M86Kzk
"""

# Instancias do problema

#Quantidade de objetos
n = 8

beneficio = [4, 3, 2, 6, 2, 3, 5, 4]

peso =      [5, 4, 3, 9, 4, 2, 6, 7]

capacidade = 20

# Vetor para guardar a solução
sol = n*[0]

# conferindo algumas das instancias
print(beneficio)
print()
print(peso)
print()
print(sol)

# Implementação Construção Gulosa 1
# Inserir na mochila os objetos de maior benefıcio enquanto for possıvel

def gulosa_1_maior_beneficio (n, beneficio, peso, capacidade) :
  #utilizando o padrão dado acima para setar o vetor de solução
  solucao = [0] * n

  # Peso total da mochila com os objetos
  peso_total = 0

  # Vamos ordenar o vetor de objetos em ordem decrescente, para priorizar aqueles de maior benefício,
  # Cumprindo com o nosso critério da construção gulosa
  # Será utilizada a função sorted para nos auxiliar nesta ordenação
  obj_maior_beneficio = sorted(range(n), key=lambda i: beneficio[i], reverse=True)


  # Agora vamos percorrer o nosso vetor de objetos ordenados, de acordo com o critério da nossa contrução gulosa,
  # para encontrar a solução desejada
  for i in obj_maior_beneficio :
    if peso[i] + peso_total <= capacidade:
  ##  if solucao == 0:
        solucao[i] = 1
        peso_total += peso[i]

  return solucao

# Implementação Construção Gulosa 2:
# Inserir na mochila os itens de menor peso

def gulosa_2_menor_peso (n, beneficio, peso, capacidade) :

  # Solução da construção
  solucao = [0] * n

  # Peso total da mochila com os objetos
  peso_total = 0

  # Vamos ordena os objetos por peso em ordem crescente,
  # para priorizar posteriormente, os objetos de menor peso
  obj_menor_peso = sorted(range(n), key=lambda i: peso[i])

  for i in obj_menor_peso :
    if peso_total + peso[i] <= capacidade :
      solucao[i] = 1
      peso_total += peso[i]

  return solucao

# Implementação Construção Gulosa 3:
# Inserir na mochila os itens de maior custo benefıcio

def gulosa_3_custo_beneficio (n, beneficio, peso, capacidade):
  # Solução da construção
  solucao = [0] * n

  # Peso total da mochila com os objetos
  peso_total = 0

  # Ordenando os itens de maior custo-benefício por ordem decrescente
  # Neste caso já iremos passar diretamente "beneficio[i] / peso[i]" como parametro na função sorted
  obj_custo_ben = sorted(range(n), key=lambda i: beneficio[i] / peso[i], reverse=True)

  for i in obj_custo_ben:
        if peso_total + peso[i] <= capacidade:
            solucao[i] = 1
            peso_total += peso[i]

  return solucao

# Agora vamos chamar os métodos de const. gulosa
solucao_1 = gulosa_1_maior_beneficio(n, beneficio, peso, capacidade)
solucao_2 = gulosa_2_menor_peso(n, beneficio, peso, capacidade)
solucao_3 = gulosa_3_custo_beneficio(n, beneficio, peso, capacidade)

# Vamos exibir nossas soluções
print(f"Solução do Método Guloso 1 - Maior Benefício: {solucao_1}")
print()
print(f"Solução do Método Guloso 2 - Menor Peso: {solucao_2}")
print()
print(f"Solução do Método Guloso 3 - Maior Custo Benefício: {solucao_3}")